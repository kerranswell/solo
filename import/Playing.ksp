
macro Playing_on_init

    // stores operation time start
    struct _PlayingTimeOperation
        declare fadeIn
        declare vibrato
        declare pitchTable
    end struct

    struct _Playing

        declare sys // EVENT_ID
        declare note // actual note

        declare string // string on the guitar
        declare fret // fret taken

        declare &_PlayMode playMode

        //  if # -1 than this note is a child note, connected to first taken note 
        // (used when triggering vibrato or slide while parent note is sounding)
        declare parent

        declare active // when several notes connected, one of them is active, i.e. sounds right now

        // when the note stops because new the same note on the same string is triggered, first one is marked as ghost (and all its children)
        // that is done, because on release we need to delineate old note from the new one or both will be released just because old was stopped 
        // ghost notes live till next release event and go away peacefully and silently while noone sees it.
        declare ghost

        { Time operations }
        declare startTime

        declare &_PlayingTimeOperation timeOp
    end struct

    declare &_Playing Playing[Globals.maxVoices]
    Playing_resetAll()

end macro


function Playing_startPitchTableCycle(i, string)
    if ((Playing[i].string = string or string = Const.stringCount+1) and Playing[i].timeOp.pitchTable = -1)
        Playing[i].timeOp.pitchTable := Funcs.Time_getCurrentTime()
    end if
end function

function Playing_startVibratoCycle(i)
    if (Playing[i].sys # -1 and Playing[i].ghost = 0 and Playing[i].playMode.rh_Muted = 0)
        Playing[i].timeOp.vibrato := 0
    end if
end function

function Playing_timeOperationsStartWithChilds(i)
    declare j
    for j := 0 to Globals.maxVoices-1
        if (Playing[j].sys # -1 and Playing[j].parent = i or i = j)
            Playing_timeOperationsStart(j)
        end if
    end for
end function

function Playing_timeOperationsStart(i)
    Playing[i].startTime := Funcs.Time_getCurrentTime()

    if (playMode.legato = 1)
        // starting fade-in operation
        // Playing[i].timeOp.fadeIn := 0
        // change_vol(Playing[i].sys, VOLUME_MIN, 0)
        fade_in(Playing[i].sys, timeOperationTotals.fadeIn * 1000)
    end if

    if (playModeGlobal.vibratoDepth > 0)
        Playing_startVibratoCycle(i)
    end if

    if (playMode.slideIn = 1)

    end if

end function

function Playing_getIndex(_note, string) -> result
    declare i := 0
    declare break := 0

    while (i < Globals.maxVoices and break = 0)
        if (Playing[i].note = _note and (Playing[i].string = string or string = 0) and Playing[i].parent = -1)
            break := 1 {found note, index will be current i. Thus before i++ we have to do i--}
            dec(i)
        end if

        inc(i)
    end while

    result := -1
    if (i < Globals.maxVoices)
        result := i
    end if
end function

function Playing_getGhostIndex(sys) -> result
    declare i := 0
    // debug("cur_sys " & sys)
    // debug_Playing()
    while (i < Globals.maxVoices and (Playing[i].sys # sys or Playing[i].ghost # 1 or Playing[i].parent # -1))
        inc(i)
    end while

    result := -1
    if (i < Globals.maxVoices)
        result := i
    end if
    // debug("result " & result)
end function

function Playing_push(sys, _note, string, fret, active) -> result
    declare i := 0

    while (i < Globals.maxVoices and (Playing[i].sys # -1 or Playing[i].ghost = 1)) // looking for first unempty slot which is not ghost note
        inc(i)
    end while

    if (i < Globals.maxVoices)
        Playing[i].sys := sys
        Playing[i].note := _note
        Playing[i].string := string
        Playing[i].fret := fret

        Playing[i].active := active

        PlayMode_copy(Playing[i].playMode, playMode)
    end if

    result := i

end function

function Playing_startChildren(i)
    declare j
    macro createChild(#p#, #v#, active)
        j := Playing_createChild(i, active)
        if (j # -1)
            // Playing[j].#p# := #v# // main feature of this child
            PlayMode_change(Playing[j].playMode, ExtEventType.#p#, #v#) // preparing local play mode for allowing groups
            PlayMode_change(playMode, ExtEventType.#p#, #v#) // preparing local play mode for allowing groups
            Groups_prepare()

            Playing[j].sys := play_note(Playing[j].note, getVelocity(Playing[j].string, Playing[j].fret), Playing[j].playMode.offset, -1)

            // volume off
            if (active = 0)
                change_vol(Playing[j].sys, VOLUME_MIN, 1)
            else 
                change_vol(Playing[i].sys, VOLUME_MIN, 1)
            end if
            
        end if        
    end macro
{
    if (Playing[i].playMode.lh_Vibrato = 0)
        createChild(lh_Vibrato, 1)
    end if

    if (Playing[i].playMode.lh_Vibrato = 1)
        createChild(lh_Vibrato, 0)
    end if
}
    if (playModeGlobal.slideIn = 1)
        createChild(slideIn, 1, 1)
    end if

    // debug2('test')
    // debug_Playing()

end function

function Playing_getFreeSlotIndex -> result
    declare i := 0
    while (i < Globals.maxVoices and Playing[i].sys # -1)
        inc(i)
    end while

    result := -1
    if (i < Globals.maxVoices)
        result := i
    end if
end function

function Playing_createChild(i, active) -> result
    declare j
    j := Playing_getFreeSlotIndex()

    if (j # -1)
        Playing_copySlot(i,j)

        Playing[j].parent := i

        if (active = 1)
            Playing[j].active := 1
            Playing[i].active := 0
        else 
            Playing[j].active := 0
        end if
    else 
        message(@MSG_MAX_VOICE_REACHED)
    end if

    result := j
end function

function Playing_copySlot(i,j)

    macro copyProp(#p#)
        Playing[j].#p# := Playing[i].#p#
    end macro

    copyProp(sys)
    copyProp(note)

    copyProp(string)
    copyProp(fret)

    PlayMode_copy(Playing[j].playMode, Playing[i].playMode)

    copyProp(parent)
    copyProp(active)

    copyProp(ghost)

end function

function Playing_remove(_note, string)
    declare i := 0
    while (i < Globals.maxVoices and (Playing[i].note # _note or Playing[i].string # string))
        inc(i)
    end while

    if (i < Globals.maxVoices)
        Playing_resetItem(i)
    end if

end function

function Playing_resetAll
    for i := 0 to Globals.maxVoices-1
        Playing_resetItem(i)            
    end for
end function

function Playing_resetItem(i)
    Playing[i].note := -1
    Playing[i].sys := -1
    Playing[i].string := -1
    Playing[i].fret := -1
    // Playing[i].playMode.letRing := 0
    PlayMode_initPlayMode(Playing[i].playMode)

    Playing[i].ghost := 0
    Playing[i].parent := -1
    Playing[i].active := 0

    Playing[i].startTime := -1
    Playing[i].timeOp.fadeIn := -1
    Playing[i].timeOp.vibrato := -1
    Playing[i].timeOp.pitchTable := -1
end function

function Playing_resetItemWithChilds(i)
    declare j

    // reset all children notes
    for j := 0 to Globals.maxVoices-1
        if (Playing[j].parent = i)
            Playing_resetItem(j)
        end if
    end for

    Playing_resetItem(i)
end function

function Playing_vibratoTrigger(ton)

    macro trigger(#p#, #new_value#, #parent_condition#)
        declare i // note to be morphed to vibrato
        declare j // child note to be created and morphed to
        for i := 0 to Globals.maxVoices-1
            if (Playing[i].sys # -1 and Playing[i].ghost = 0 and Playing[i].parent = -1 and Playing[i].#p# # #new_value# #parent_condition#)
                for j := 0 to Globals.maxVoices-1
                    if (Playing[j].sys # -1 and Playing[j].ghost = 0 and Playing[j].parent = i and Playing[j].#p# = #new_value#)

                        // crossfade to sounds
                        change_vol(Playing[i].sys, VOLUME_MIN, 0)
                        change_vol(Playing[j].sys, VOLUME_MAX, 0)

                        Playing[i].active := 0
                        Playing[j].active := 1

                    end if
                end for
            end if
        end for        
    end macro

    trigger(playMode.lh_Vibrato, ton, and Playing[i].playMode.rh_Muted = 0)

    // debug("after controller")
    // debug_Playing()

end function

function Playing_isOverlapping(string, note) -> result
    result := 0
    declare i

    for i := 0 to Globals.maxVoices-1
        if (Playing[i].sys # -1 and Playing[i].ghost = 0 and Playing[i].string = string and Playing[i].note # note)
            Playing_getActiveProperty(playMode.letRing, i, tmp2, tmp)
            if (tmp2 = 0)
                result := 1
            end if            
        end if
    end for
end function

macro Playing_getActiveProperty(#p#, i, #var#, #index_var#)
    #var# := Playing[i].#p#

    for #index_var# := 0 to Globals.maxVoices-1
        if (Playing[#index_var#].active = 1 and Playing[#index_var#].parent = i)
            #var# := Playing[#index_var#].#p#
        end if
    end for
end macro

macro Playing_setPropertyTree(#p#, i, v, #index_var#)
    Playing[i].#p# := v

    for #index_var# := 0 to Globals.maxVoices-1
        if (Playing[#index_var#].parent = i)
            Playing[#index_var#].#p# := v
        end if
    end for
end macro

function Playing_getActiveIndex(i) -> result
    declare j
    result := -1
    if (Playing[i].active = 1)
        result := i
    else 
        for j := 0 to Globals.maxVoices-1
            if (Playing[j].sys # -1 and j # i and Playing[j].active = 1 and (Playing[j].parent = i and Playing[i].parent = -1 or (Playing[j].parent = -1 or Playing[j].parent = Playing[i].parent) and Playing[i].parent # -1))
                result := i
            end if
        end for
    end if
end function
