function Playing_startVibratoCycle(i)
    if (Playing.sys[i] # -1 and Playing.ghost[i] = 0 and Playing.rh_Muted[i] = 0)
        Playing.to_vibrato[i] := 0
    end if
end function

function Playing_timeOperationsStartWithChilds(i)
    declare j
    for j := 0 to num_elements(Playing.sys)-1
        if (Playing.sys[j] # -1 and Playing.parent[j] = i or i = j)
            Playing_timeOperationsStart(j)
        end if
    end for
end function

function Playing_timeOperationsStart(i)
    Playing.startTime[i] := Funcs.Time_getCurrentTime()

    if (PlayMode.legato = 1)
        // starting fade-in operation
        // Playing.to_fadeIn[i] := 0
        // change_vol(Playing.sys[i], VOLUME_MIN, 0)
        fade_in(Playing.sys[i], timeOperationTotals.fadeIn * 1000)
    end if

    if (PlayModeGlobal.vibratoDepth > 0)
        Playing_startVibratoCycle(i)
    end if

end function

function Playing_getIndex(_note, string) -> result
    declare i := 0
    declare break := 0

    while (i < num_elements(Playing.sys) and break = 0)
        if (Playing.note[i] = _note and (Playing.string[i] = string or string = 0) and Playing.parent[i] = -1)
            break := 1 {found note, index will be current i. Thus before i++ we have to do i--}
            dec(i)
        end if

        inc(i)
    end while

    result := -1
    if (i < num_elements(Playing.sys))
        result := i
    end if
end function

function Playing_getGhostIndex(sys) -> result
    declare i := 0
    // debug("cur_sys " & sys)
    // debug_Playing()
    while (i < num_elements(Playing.sys) and (Playing.sys[i] # sys or Playing.ghost[i] # 1 or Playing.parent[i] # -1))
        inc(i)
    end while

    result := -1
    if (i < num_elements(Playing.sys))
        result := i
    end if
    // debug("result " & result)
end function

function Playing_push(sys, _note, string, fret, active) -> result
    declare i := 0

    while (i < num_elements(Playing.sys) and (Playing.sys[i] # -1 or Playing.ghost[i] = 1)) // looking for first unempty slot which is not ghost note
        inc(i)
    end while

    if (i < num_elements(Playing.sys))
        Playing.sys[i] := sys
        Playing.note[i] := _note
        Playing.string[i] := string
        Playing.fret[i] := fret

        Playing.active[i] := active

        Playing_setArts(i)
    end if

    result := i

end function

function Playing_startChildren(i)
    declare j
    macro createChild(#p#, #v#)
        j := Playing_createChild(i)
        if (j # -1)
            Playing.#p#[j] := #v# // main feature of this child
            PlayMode_change(ExtEventType.#p#, #v#) // preparing local play mode for allowing groups
            Groups_prepare()

            Playing.sys[j] := play_note(Playing.note[j], getVelocity(Playing.string[j], Playing.fret[j]), Control_getAttackSoftness(), -1)

            // volume off
            change_vol(Playing.sys[j], VOLUME_MIN, 1)
        end if        
    end macro
{
    if (Playing.lh_Vibrato[i] = 0)
        createChild(lh_Vibrato, 1)
    end if

    if (Playing.lh_Vibrato[i] = 1)
        createChild(lh_Vibrato, 0)
    end if
}
    // debug2('test')
    // debug_Playing()

end function

function Playing_getFreeSlotIndex -> result
    declare i := 0
    while (i < num_elements(Playing.sys) and Playing.sys[i] # -1)
        inc(i)
    end while

    result := -1
    if (i < num_elements(Playing.sys))
        result := i
    end if
end function

function Playing_createChild(i) -> result
    declare j
    j := Playing_getFreeSlotIndex()

    if (j # -1)
        Playing_copySlot(i,j)

        Playing.parent[j] := i
        Playing.active[j] := 0
    else 
        message(@MSG_MAX_VOICE_REACHED)
    end if

    result := j
end function

function Playing_copySlot(i,j)

    macro copyProp(#p#)
        Playing.#p#[j] := Playing.#p#[i]
    end macro

    copyProp(sys)
    copyProp(note)

    copyProp(string)
    copyProp(fret)

    copyProp(letRing)
    copyProp(rh_Muted)
    copyProp(pickDown)
    copyProp(lh_Vibrato)

    copyProp(parent)
    copyProp(active)

    copyProp(ghost)

end function

function Playing_remove(_note, string)
    declare i := 0
    while (i < num_elements(Playing.sys) and (Playing.note[i] # _note or Playing.string[i] # string))
        inc(i)
    end while

    if (i < num_elements(Playing.sys))
        Playing_resetItem(i)
    end if

end function

function Playing_resetAll
    for i := 0 to num_elements(Playing.sys)-1
        Playing_resetItem(i)            
    end for
end function

function Playing_resetItem(i)
    Playing.note[i] := -1
    Playing.sys[i] := -1
    Playing.string[i] := -1
    Playing.fret[i] := -1
    Playing.letRing[i] := 0

    Playing.ghost[i] := 0
    Playing.parent[i] := -1
    Playing.active[i] := 0

    Playing.startTime[i] := -1
    Playing.to_fadeIn[i] := -1
    Playing.to_vibrato[i] := -1
end function

function Playing_resetItemWithChilds(i)
    declare j

    // reset all children notes
    for j := 0 to Globals.maxVoices-1
        if (Playing.parent[j] = i)
            Playing_resetItem(j)
        end if
    end for

    Playing_resetItem(i)
end function

function Playing_setArts(i)
    Playing.rh_Muted[i] := PlayMode.rh_Muted
    Playing.pickDown[i] := PlayMode.pickDown
    Playing.lh_Vibrato[i] := PlayMode.lh_Vibrato
    Playing.letRing[i] := PlayMode.letRing
end function

function Playing_vibratoTrigger(ton)

    macro trigger(#p#, #new_value#, #parent_condition#)
        declare i // note to be morphed to vibrato
        declare j // child note to be created and morphed to
        for i := 0 to num_elements(Playing.sys)-1
            if (Playing.sys[i] # -1 and Playing.ghost[i] = 0 and Playing.parent[i] = -1 and Playing.#p#[i] # #new_value# #parent_condition#)
                for j := 0 to num_elements(Playing.sys)-1
                    if (Playing.sys[j] # -1 and Playing.ghost[j] = 0 and Playing.parent[j] = i and Playing.#p#[j] = #new_value#)

                        // crossfade to sounds
                        change_vol(Playing.sys[i], VOLUME_MIN, 0)
                        change_vol(Playing.sys[j], VOLUME_MAX, 0)

                        Playing.active[i] := 0
                        Playing.active[j] := 1

                    end if
                end for
            end if
        end for        
    end macro

    trigger(lh_Vibrato, ton, and Playing.rh_Muted[i] = 0)

    // debug("after controller")
    // debug_Playing()

end function

function Playing_isOverlapping(string, note) -> result
    result := 0
    declare i

    for i := 0 to num_elements(Playing.sys)-1
        if (Playing.sys[i] # -1 and Playing.ghost[i] = 0 and Playing.string[i] = string and Playing.note[i] # note)
            Playing_getActiveProperty(letRing, i, tmp2, tmp)
            if (tmp2 = 0)
                result := 1
            end if            
        end if
    end for
end function

macro Playing_getActiveProperty(#p#, i, #var#, #index_var#)
    #var# := Playing.#p#[i]

    for #index_var# := 0 to num_elements(Playing.active)-1
        if (Playing.active[#index_var#] = 1 and Playing.parent[#index_var#] = i)
            #var# := Playing.#p#[#index_var#]
        end if
    end for
end macro

macro Playing_setPropertyTree(#p#, i, v, #index_var#)
    Playing.#p#[i] := v

    for #index_var# := 0 to num_elements(Playing.#p#)-1
        if (Playing.parent[#index_var#] = i)
            Playing.#p#[#index_var#] := v
        end if
    end for
end macro
