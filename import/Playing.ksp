
macro Playing_on_init

    // stores operation time start
    struct _PlayingTimeOperation
        declare fadeIn
        declare vibrato
        declare pitchTable
    end struct

    struct _Zone
        declare id
        declare length
        declare @name
    end struct

    struct _Playing

        declare sys // EVENT_ID
        declare &_GuitarNote gn
        declare &_PlayMode playMode

        //  if # -1 than this note is a child note, connected to first taken note 
        // (used when triggering vibrato or slide while parent note is sounding)
        declare parent

        declare active // when several notes connected, one of them is active, i.e. sounds right now

        { Time operations }
        declare startTime

        // ghost note (eg. slide out sound)
        declare ghost := 0

        declare &_Zone zone

        declare &_PlayingTimeOperation timeOp
    end struct

    declare &_Playing Playing[Globals.maxVoices]
    Playing_resetAll()

end macro

macro Zone_reset(#z#)
    #z#.id := -1
    #z#.length := 0
end macro

macro Zone_set(i)
    // #z#.id := get_event_par(#eid#, $EVENT_PAR_ZONE_ID)
    // #z#.length := get_sample_length(#z#.id)    
    // Playing[i].zone.id := Board_getZoneCode(Playing[i].gn.string, Playing[i].gn.fret, Globals.lastGroupIndex)
    // Playing[i].zone.length := %zone_lengths[Playing[i].zone.id]
    Playing[i].zone.id := get_event_par(Playing[i].sys, $EVENT_PAR_ZONE_ID)
    Playing[i].zone.length := get_sample_length(Playing[i].zone.id)
    // TODO: optimize by saving in an array sample lengths here (first run)
end macro

function Playing_startPitchTableCycle(i, string)
    if ((Playing[i].gn.string = string or string = Const.stringCount+1) and Playing[i].timeOp.pitchTable = -1)
        Playing[i].timeOp.pitchTable := Funcs.Time_getCurrentTime()
    end if
end function

function Playing_startVibratoCycle(i)
    if (Playing[i].sys # -1 and Playing[i].playMode.rh_Muted = 0)
        Playing[i].timeOp.vibrato := 0
    end if
end function

function Playing_timeOperationsStartWithChilds(i)
    declare j
    for j := 0 to Globals.maxVoices-1
        if (Playing[j].sys # -1 and Playing[j].parent = i or i = j)
            Playing_timeOperationsStart(j)
        end if
    end for
end function

function Playing_timeOperationsStart(i)
    if (Playing[i].playMode.legato = 1)
        // starting fade-in operation
        // Playing[i].timeOp.fadeIn := 0
        // change_vol(Playing[i].sys, VOLUME_MIN, 0)
        fade_in(Playing[i].sys, timeOperationTotals.fadeIn * 1000)
    end if

    if (playModeGlobal.vibratoDepth > 0)
        Playing_startVibratoCycle(i)
    end if

    if (Playing[i].playMode.slideIn = 1)

    end if

end function

function Playing_getIndex(_note, string) -> result
    declare i := 0
    declare break := 0

    while (i < Globals.maxVoices and break = 0)
        if (Playing[i].gn.note = _note and (Playing[i].gn.string = string or string = 0) and Playing[i].parent = -1)
            break := 1 {found note, index will be current i. Thus before i++ we have to do i--}
            dec(i)
        end if

        inc(i)
    end while

    result := -1
    if (i < Globals.maxVoices)
        result := i
    end if
end function

function Playing_getIndexBySys(sys) -> result
    declare i
    result := -1
    for i := 0 to Globals.maxVoices-1
        if (Playing[i].sys = sys)
            result := i
            break(i, Globals.maxVoices)
        end if
    end for
end function

function Playing_push(sys, _note, string, fret, active) -> result
    declare i := 0

    while (i < Globals.maxVoices and Playing[i].sys # -1)
        inc(i)
    end while

    if (i < Globals.maxVoices)
        Playing[i].sys := sys
        Playing[i].gn.note := _note
        Playing[i].gn.string := string
        Playing[i].gn.fret := fret

        Playing[i].active := active

        Playing[i].startTime := Funcs.Time_getCurrentTime()
    end if

    result := i

end function

function Playing_getDuration(i) -> result
    result := -1
    declare @zone_name
    declare zone_id

    // if (Playing[i].playMode.slideIn = 1)
    //     result := 0
    // end if
    
end function

macro createChild(#parent#, #p#, #v#, active)
    j := Playing_createChild(#parent#, active)
    if (j # -1)
        PlayMode_change(Playing[j].playMode, ExtEventType.#p#, #v#) // preparing play mode for allowing groups

        Playing[j].playMode.duration := Playing_getDuration(j)

        Playing_playNote(j)
    end if        
end macro


function Playing_startSlideOut(i, value)
    declare j
    createChild(i, slideOut, playModeGlobal.pm.slideOut, 1)
end function

function Playing_startChildren(i)
    declare j
{   if (Playing[i].playMode.lh_Vibrato = 0)
        createChild(lh_Vibrato, 1, 0)
    end if

    if (Playing[i].playMode.lh_Vibrato = 1)
        createChild(lh_Vibrato, 0, 0)
    end if
}
    if (playModeGlobal.pm.slideIn > 0)
        createChild(i, slideIn, playModeGlobal.pm.slideIn, 1)
        if (j # -1)
            declare group_index
            declare ev
            group_index := Globals.lastGroupIndex
            ev := epSpeed(V2E, Funcs.linearEq(Playing[j].playMode.slideIn, 1, 30, 127, 150, 100) / 10) 
            set_engine_par($ENGINE_PAR_SPEED, ev, group_index, -1, -1)            
        end if
    end if

    // debug2('test')
    // debug_Playing()

end function

function Playing_playNote(i)
    Groups_prepare(i)
    Playing[i].sys := play_note(Playing[i].gn.note, getVelocity(Playing[i].gn.string, Playing[i].gn.fret), Playing[i].playMode.offset, Playing[i].playMode.duration)
    Zone_set(i)
    change_vol(Playing[i].sys, VOLUME_MIN, 0)
    Playing_changeTune(i, 0, 0)
end function

function Playing_getFreeSlotIndex -> result
    declare i := 0
    while (i < Globals.maxVoices and Playing[i].sys # -1)
        inc(i)
    end while

    result := -1
    if (i < Globals.maxVoices)
        result := i
    end if
end function

function Playing_createChild(i, active) -> result
    declare j
    j := Playing_getFreeSlotIndex()

    if (j # -1)
        Playing_copySlot(i,j)
        Playing[j].startTime := Funcs.Time_getCurrentTime()

        Playing[j].parent := i

        if (active = 1)
            Playing[j].active := 1
            Playing[i].active := 0
        else 
            Playing[j].active := 0
        end if
    else 
        message(@MSG_MAX_VOICE_REACHED)
    end if

    result := j
end function

function Playing_copySlot(i,j)

    macro copyProp(#p#)
        Playing[j].#p# := Playing[i].#p#
    end macro

    copyProp(sys)
    copyProp(gn.note)
    copyProp(gn.string)
    copyProp(gn.fret)

    PlayMode_copy(Playing[j].playMode, Playing[i].playMode)

    copyProp(parent)
    copyProp(active)

end function

function Playing_remove(_note, string)
    declare i := 0
    while (i < Globals.maxVoices and (Playing[i].gn.note # _note or Playing[i].gn.string # string))
        inc(i)
    end while

    if (i < Globals.maxVoices)
        Playing_resetItem(i)
    end if

end function

function Playing_resetAll
    for i := 0 to Globals.maxVoices-1
        Playing_resetItem(i)            
    end for
end function

function Playing_resetItem(i)
    if (Playing[i].sys > 0 and Playing[i].parent = -1)
        UI_Hit_resetByMasterSys(Playing[i].sys)        
    end if
    Playing[i].gn.note := -1
    Playing[i].sys := -1
    // Zone_reset(Playing[i].zone)
    Playing[i].gn.string := -1
    Playing[i].gn.fret := -1
    // Playing[i].playMode.letRing := 0
    PlayMode_resetPlayMode(Playing[i].playMode)

    Playing[i].parent := -1
    Playing[i].active := 0
    Playing[i].ghost := 0

    Playing[i].startTime := -1
    Playing[i].timeOp.fadeIn := -1
    Playing[i].timeOp.vibrato := -1
    Playing[i].timeOp.pitchTable := -1
end function

function Playing_resetItemWithChilds(i)
    declare j

    // reset all children notes
    for j := 0 to Globals.maxVoices-1
        if (Playing[j].parent = i)
            Playing_resetItem(j)
        end if
    end for

    Playing_resetItem(i)
end function

function Playing_vibratoTrigger(ton)

    macro trigger(#p#, #new_value#, #parent_condition#)
        declare i // note to be morphed to vibrato
        declare j // child note to be created and morphed to
        for i := 0 to Globals.maxVoices-1
            if (Playing[i].sys # -1 and Playing[i].parent = -1 and Playing[i].#p# # #new_value# #parent_condition#)
                for j := 0 to Globals.maxVoices-1
                    if (Playing[j].sys # -1 and Playing[j].parent = i and Playing[j].#p# = #new_value#)

                        // crossfade to sounds
                        change_vol(Playing[i].sys, VOLUME_MIN, 0)
                        change_vol(Playing[j].sys, VOLUME_MAX, 0)

                        Playing[i].active := 0
                        Playing[j].active := 1

                    end if
                end for
            end if
        end for        
    end macro

    trigger(playMode.lh_Vibrato, ton, and Playing[i].playMode.rh_Muted = 0)

    // debug("after controller")
    // debug_Playing()

end function

function Playing_isOverlapping(string, note) -> result
    result := 0
    declare i
    declare tmp
    declare tmp2
    for i := 0 to Globals.maxVoices-1
        if (Playing[i].sys # -1 and Playing[i].gn.string = string and Playing[i].gn.note # note and Playing[i].ghost = 0)
            result := 1
        end if
    end for
end function

function Playing_isOverlappingEvents(note) -> result
    result := 0
    declare i
    for i := 0 to Globals.maxVoices-1
        if (Playing[i].sys # -1 and Playing[i].gn.note # note)
            result := 1
        end if
    end for
end function

macro Playing_getActiveProperty(#p#, i, #var#, #index_var#)
    #var# := Playing[i].#p#

    for #index_var# := 0 to Globals.maxVoices-1
        if (Playing[#index_var#].active = 1 and Playing[#index_var#].parent = i)
            #var# := Playing[#index_var#].#p#
        end if
    end for
end macro

macro Playing_setPropertyTree(#p#, i, v, #index_var#)
    Playing[i].#p# := v

    for #index_var# := 0 to Globals.maxVoices-1
        if (Playing[#index_var#].parent = i)
            Playing[#index_var#].#p# := v
        end if
    end for
end macro

function Playing_getActiveIndex(i) -> result
    declare j
    result := -1
    if (Playing[i].active = 1)
        result := i
    else 
        for j := 0 to Globals.maxVoices-1
            if (Playing[j].sys # -1 and j # i and Playing[j].active = 1 and (Playing[j].parent = i and Playing[i].parent = -1 or (Playing[j].parent = -1 or Playing[j].parent = Playing[i].parent) and Playing[i].parent # -1))
                result := j
            end if
        end for
    end if
end function

function Playing_getParentIndex(i) -> result
    declare j
    result := i
    if (Playing[i].parent # -1)
        result := Playing[i].parent
    end if
end function

function Playing_stopAllNotes
    declare i
    for i := 0 to Globals.maxVoices-1
        if (Playing[i].parent = -1)
            Playing_stopNote(i)
        end if
    end for    
end function

function Playing_stopNotesOnString(string)
    declare i
    for i := 0 to Globals.maxVoices-1
        if (Playing[i].gn.string = string and Playing[i].parent = -1)
            // debug("stop: " & Playing[i].sys)
            Playing_stopNote(i)
        end if
    end for
end function

function Playing_stopNote(i)

    Playing_stopChildren(i)

    note_off(Playing[i].sys)
    Playing_resetItemWithChilds(i)
    UI_stopNote(i)

end function

function Playing_stopChildren(i)
    declare j

    // stop all children
    for j := 0 to Globals.maxVoices-1
        if (Playing[j].parent = i)
            note_off(Playing[j].sys)
        end if
    end for    
end function


function Playing_maxVoicesReached() -> result
    declare i := 0
    while (i < Globals.maxVoices and Playing[i].sys # -1)
        inc(i)
    end while
    
    result := 0
    if (i = Globals.maxVoices)
        result := 1
    end if    
end function

function Playing_changeTune(i, val, rel)
    declare value := val
    if (rel = 0)
        value := value + Globals.pitchBend
    end if

    if (Globals.opString = 0 or Globals.opString = Playing[i].gn.string)
        change_tune(Playing[i].sys, value, rel)
    end if
end function

