import "import/Const.ksp"import "import/PlayMode.ksp"import "import/Playing.ksp"import "import/Control.ksp"import "import/Groups.ksp"import "import/Board.ksp"import "import/debug.ksp"import "import/PitchTable.ksp"import "import/Functions.ksp" as Funcsimport "import/KSPMathV702.ksp"on init    {#pragma save_compiled_source solo-s1.txt}    Const_on_init()    message("")    set_script_title("S1")	make_perfview	set_ui_height_px(200)    { *********** LOCAL VARS ********** }	{ ********* DECLARE VARIABLES ********** }    declare @MSG_MAX_VOICE_REACHED := "Max voices reached"    declare const VOLUME_NONE := -100000    declare const VOLUME_MIN := -66000    declare const VOLUME_DEFAULT := 0    declare const VOLUME_MAX := 0    declare const VIBRATO_SPEED_DEFAULT := 55    family timeOperationPeriods        declare fadeIn := 1 // ms        declare vibrato := 1         declare pitchTable := 1     end family    family timeOperationTotals        declare fadeIn := 30 // ms        declare vibrato := 0     end family    family timeOperationValues        declare fadeIn_start        declare fadeIn_end        declare vibratoDepthMax := 1 * 100000 // 1 halftones in millicents    end family    timeOperationValues.fadeIn_start := VOLUME_MIN    timeOperationValues.fadeIn_end := VOLUME_DEFAULT    PlayMode_on_init()    declare activeGroups[Globals.maxGroups]    const ExtEventType        pickDown        rh_Muted        lh_Vibrato        altStroke        letRing        vibratoSpeed        vibratoDepth        triggerPT        slideIn        slideOut        pitchBend    end const    Playing_on_init()    Board_on_init()        family velocityArtZones        declare rh_Muted_Down[2] := (26, 50)        declare rh_Muted_Up[2] := (0, 25)        declare rh_Opened_Down[2] := (76, 100)        declare rh_Opened_Up[2] := (51, 75)        declare lh_Vibrato[2] := (101, 127)        // declare letRing_Down[2] := (127, 127)        // declare letRing_Up[2] := (126, 126)    end family    PitchTable_on_init()	{ ********* DECLARE UI *************** }    family UI        declare ui_button triggerPT[7]        declare read ui_switch softMute        declare ui_switch rh_Muted        declare ui_switch lh_Vibrato        declare ui_switch altStroke        declare ui_switch letRing        declare ui_switch pickVelocityControl        declare ui_button debugClear        declare ui_knob attackSoftness (0, 100, 1)        // declare ui_knob vibratoSpeed (-50, 50, 1)        declare read ui_knob vibratoSpeed (0, 100, 1)        declare ui_knob vibratoDepth (0, 100, 1)        declare ui_label label (2,6)        declare ui_label label2 (2,6)    end family    for i := 0 to Const.stringCount        if (i = 0)            set_button_properties(UI.triggerPT[i], "A")        else             set_button_properties(UI.triggerPT[i], i)        end if    end for        set_text(UI.label,"")     set_text(UI.label2,"")     UI.softMute := 0    set_text(UI.softMute, "Soft P.M.")    UI.rh_Muted := playModeGlobal.rh_Muted    set_text(UI.rh_Muted, "P.M.")    UI.lh_Vibrato := playModeGlobal.lh_Vibrato    set_text(UI.lh_Vibrato, "Vibrato")    UI.altStroke := playModeGlobal.altStroke    set_text(UI.altStroke, "Alt Stroke")    UI.letRing := playModeGlobal.letRing    set_text(UI.letRing, "Let Ring")    UI.pickVelocityControl := 1    if (playModeGlobal.altStroke = 1)        UI.pickVelocityControl := 0    end if    set_text(UI.pickVelocityControl, "Velocity Control")    UI.attackSoftness := 0    set_text(UI.attackSoftness, "Att. Softness")        UI.vibratoSpeed := VIBRATO_SPEED_DEFAULT    set_text(UI.vibratoSpeed, "Vib. Speed")    set_knob_defval(UI.vibratoSpeed, VIBRATO_SPEED_DEFAULT)    UI.vibratoDepth := 0    set_text(UI.vibratoDepth, "Vib. Depth")    set_knob_defval(UI.vibratoDepth, 0)    set_text(UI.debugClear, "Debug Clear")    UI.debugClear := 0    { ************ MISC INIT ************ }    set_listener($NI_SIGNAL_TRANSP_STOP,1)    set_listener($NI_SIGNAL_TIMER_MS, 1000) // micro seconds    SetMathMode(ALL, CD)end onon note    message("")    onNote()end onon release     message("")    onRelease()end onfunction onNote()    ignore_event($EVENT_ID)    declare max    declare string    declare fret    declare i    max := Playing_maxVoicesReached() // no room for new note ?     string := getString($EVENT_NOTE)    fret := getFret($EVENT_NOTE)    if (max = 0 and string > 0 and fret # -1) // if max voices not reached        setPlayMode($EVENT_VELOCITY, string, $EVENT_NOTE)        // stop all notes playing on this string        Playing_stopNotesOnString(string)        PlayMode_nextNoteInit()        // creating new note        i := Playing_push(-1, $EVENT_NOTE, string, fret, 1)        if (i # -1)            PlayMode_copy(Playing[i].playMode, playMode)            PlayMode_setOpString(i)            Playing_playNote(i)            Playing_startChildren(i)            Playing_timeOperationsStartWithChilds(i)            declare ai            ai := Playing_getActiveIndex(i)            change_vol(Playing[ai].sys, VOLUME_DEFAULT, 0)        end if    end if    if (max = 1)        message(@MSG_MAX_VOICE_REACHED)    end if        debug_Strings()    debug_Playing()end functionfunction onRelease    declare i    declare ignore := 0    declare length := 0    i := Playing_getIndexBySys($EVENT_ID)    if (i # -1)        if (Playing[i].playMode.slideIn > 0 and Playing[i].parent # -1)            // TODO: Need to choose what of the childs to activate depending on play mode (vibrato eg.)            change_vol(Playing[Playing[i].parent].sys, VOLUME_DEFAULT, 0)            Playing[Playing[i].parent].active := 1            Playing_resetItem(i)        else if (Playing[i].playMode.letRing = 1)            ignore_event($EVENT_ID)            ignore := 1        else             length := Funcs.Time_getCurrentTime() - Playing[i].startTime            Playing_stopChildren(i)            Playing_resetItem(i)                    end if    end if    if (ignore = 0)         debug("release " & $EVENT_ID & ", length: " & length)    end ifend functionon_pgs_changed// on pgs_changed    if (pgs_key_exists(pgs_pitchTableChanged))        Globals.pitchTableChanged := pgs_get_key_val(pgs_pitchTableChanged, 0)    end if    if (pgs_key_exists(pgs_pitchTableIndex))        Globals.pitchTableIndex := pgs_get_key_val(pgs_pitchTableIndex, 0)        if (pgs_key_exists(pgs_pitchTableTimeLength))            pitchTables[Globals.pitchTableIndex].timeLength := pgs_get_key_val(pgs_pitchTableTimeLength, 0)        end if        if (pgs_key_exists(pgs_pitchTablePitchRange))            pitchTables[Globals.pitchTableIndex].pitchRange := pgs_get_key_val(pgs_pitchTablePitchRange, 0)        end if        //  if (Globals.pitchTableChanged = 1)        //     // apply table changes        //     debug_PitchTable()        // end if                if (pgs_key_exists(pgs_pitchTable))            // for i := 0 to num_elements(pitchTables[Globals.pitchTableIndex].columns)-1            for i := 0 to Const.pitchTableColumnCount-1                pitchTables[Globals.pitchTableIndex].columns[i] := pgs_get_key_val(pgs_pitchTable, i)            end for        end if    end if// end onend_on