import "import/KSPMathV702.ksp" as Mathon init    {#pragma save_compiled_source solo.txt}    message("")    set_script_title("S1")	make_perfview	set_ui_height_px(200)    { *********** LOCAL VARS ********** }    declare i    declare j    declare tmp    declare tmp2    declare tmp3    declare string    declare fret    declare stop	{ ********* DECLARE VARIABLES ********** }        family PlayMode        declare rh_Muted := 0        declare pickDown := 1        declare lh_Vibrato := 0        declare altStroke := 0        declare letRing := 0    end family        const ArtsCodes        o_pd        o_pu        m_pd        m_pu        v1    end const        family Globals        declare takeCounts[ArtsCodes.SIZE]        declare const maxVoices := 10        declare const maxGroups := 3        declare lastGroupIndex := -1    end family    for i := 0 to ArtsCodes.SIZE-1        Globals.takeCounts[i] := 3    end for    Globals.takeCounts[ArtsCodes.v1] := 2    declare activeGroups[Globals.maxGroups]    const ExtEventType        pickDown        rh_Muted        lh_Vibrato        altStroke        letRing        vibratoSpeed    end const           family Playing        declare notes[Globals.maxVoices]        declare sys[Globals.maxVoices]         declare string[Globals.maxVoices]        declare fret[Globals.maxVoices]        declare letRing[Globals.maxVoices]        declare rh_Muted[Globals.maxVoices]        declare pickDown[Globals.maxVoices]        declare lh_Vibrato[Globals.maxVoices]        declare connected[Globals.maxVoices]        // declare emptyArray[Globals.maxVoices]    end family{     for i := 0 to Globals.maxVoices-1        emptyArray[i] := -1    end for }       Playing_resetAll()    family GhostNotes        declare sys[Globals.maxVoices]    end family        GhostNotes_resetAll()        declare notes2strings[128]    declare notes2frets[128]    fillBoardTable()        family velocityArtZones        declare rh_Muted_Down[2] := (26, 50)        declare rh_Muted_Up[2] := (0, 25)        declare rh_Opened_Down[2] := (76, 100)        declare rh_Opened_Up[2] := (51, 75)        declare lh_Vibrato[2] := (101, 125)        declare letRing_Down[2] := (127, 127)        declare letRing_Up[2] := (126, 126)    end family    	{ ********* DECLARE UI *************** }    family UI        declare ui_switch rh_Muted        declare ui_switch lh_Vibrato        declare ui_switch altStroke        declare ui_switch letRing        declare ui_switch velocityControl        declare ui_knob attackSoftness (0, 100, 1)        {declare ui_knob vibratoSpeed (-330, 280, 10)}        declare ui_knob vibratoSpeed (-50, 50, 1)        declare ui_label label (2,6)        declare ui_label label2 (2,6)    end family        set_text(UI.label,"")     set_text(UI.label2,"")     UI.rh_Muted := PlayMode.rh_Muted    set_text(UI.rh_Muted, "P.M.")    UI.lh_Vibrato := PlayMode.lh_Vibrato    set_text(UI.lh_Vibrato, "Vibrato")    UI.altStroke := PlayMode.altStroke    set_text(UI.altStroke, "Alt Stroke")    UI.altStroke := PlayMode.letRing    set_text(UI.letRing, "Let Ring")    UI.velocityControl := 1    set_text(UI.velocityControl, "Velocity Control")    UI.attackSoftness := 0    set_text(UI.attackSoftness, "Att. Softness")        UI.vibratoSpeed := 0    set_text(UI.vibratoSpeed, "Vib. Speed")    set_knob_defval(UI.vibratoSpeed, 0)    { ************ MISC INIT ************ }        set_listener($NI_SIGNAL_TRANSP_STOP,1)        Math.SetMathMode(0, CD)end onon note    debug_clear()    setPlayModeByVelocity($EVENT_VELOCITY)    nextNoteInit()        resetGroups()    setActiveGroups()    disallow_group($ALL_GROUPS)    allowGroups()        message("")    ignore_event($EVENT_ID)    string := getString($EVENT_NOTE)    fret := getFret($EVENT_NOTE)        tmp := maxVoicesReached() { no room for new note ? }    if (tmp = 0) {if max voices not reached}        i := Playing_getIndex($EVENT_NOTE, string) { is this note on this string is already playing? }        if (i >= 0 and Playing.letRing[i] = 1)            {found this note playing, but it rings in let ring mode, we need to stop it now and start the new one}            {stopped note pushes to ghost notes, so we can process its EVENT_ID on release correctly}            GhostNotes_push(Playing.sys[i])        end if        {stop all notes playing on this string}        stopNotesOnString(string)        {starting the new note}        tmp2 := play_note($EVENT_NOTE, getVelocity(string, fret), UI.attackSoftness * 300, 0)        Playing_push(tmp2, $EVENT_NOTE, string, fret)    else         message("Max voices reached or this note is already playing")    end if        debug_Strings()    end onon release     message("")    stop := -1        i := Playing_getIndex($EVENT_NOTE, 0)    j := GhostNotes_getIndex($EVENT_ID)    if (i # -1 and j = -1)        if (Playing.letRing[i] # 1) {if note started with let ring mode then do not stop it}            stop := i        end if    end if    if (j >= 0)        GhostNotes_remove(GhostNotes.sys[i])    end if    if (stop # -1)        stopNote(stop)    end ifend on{ ********** FUNCTIONS *********** } function stopAllNotes    declare i    for i := 0 to Globals.maxVoices-1        stopNote(i)    end for    end functionfunction stopNotesOnString(string)    declare i    for i := 0 to Globals.maxVoices-1        if (Playing.string[i] = string)            stopNote(i)        end if    end forend functionfunction stopNote(i)    declare i    note_off(Playing.sys[i])    Playing_remove(Playing.notes[i], Playing.string[i])end functionfunction nextNoteInit    if (PlayMode.altStroke = 1 and UI.velocityControl = 0)        if (PlayMode.pickDown = 1)            PlayMode.pickDown := 0        else             PlayMode.pickDown := 1        end if    end ifend functionfunction getVelocity(string, fret) -> result    result := (string-1) * 3 + 1 + fret / 12end functionfunction maxVoicesReached() -> result    declare i := 0    while (i < Globals.maxVoices and Playing.notes[i] # -1)        inc(i)    end while        result := 0    if (i = Globals.maxVoices)        result := 1    end if    end functionimport "import/Control.ksp"import "import/PlayMode.ksp"import "import/Playing.ksp"import "import/Groups.ksp"import "import/GhostNotes.ksp"import "import/Board.ksp"import "import/debug.ksp"import "import/Functions.ksp" as Funcs