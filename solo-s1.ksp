import "import/Const.ksp"import "import/KSPMathV702.ksp"import "import/playMode.ksp"import "import/Playing.ksp"import "import/Control.ksp"import "import/Groups.ksp"import "import/Board.ksp"import "import/debug.ksp"import "import/PitchTable.ksp"import "import/Functions.ksp" as Funcson init    {#pragma save_compiled_source solo-s1.txt}    Const_on_init()    message("")    set_script_title("S1")	make_perfview	set_ui_height_px(200)    { *********** LOCAL VARS ********** }{    declare i    declare j    declare tmp    declare tmp2    declare tmp3    declare string    declare fret    declare stop}	{ ********* DECLARE VARIABLES ********** }    declare @MSG_MAX_VOICE_REACHED := "Max voices reached"    declare const VOLUME_NONE := -100000    declare const VOLUME_MIN := -66000    declare const VOLUME_DEFAULT := 0    declare const VOLUME_MAX := 0    declare const VIBRATO_SPEED_DEFAULT := 55    family timeOperationPeriods        declare fadeIn := 1 // ms        declare vibrato := 1         declare pitchTable := 1     end family    family timeOperationTotals        declare fadeIn := 30 // ms        declare vibrato := 0     end family    family timeOperationValues        declare fadeIn_start        declare fadeIn_end        declare vibratoDepthMax := 1 * 100000 // 1 halftones in millicents    end family    timeOperationValues.fadeIn_start := VOLUME_MIN    timeOperationValues.fadeIn_end := VOLUME_DEFAULT    PlayMode_on_init()    declare activeGroups[Globals.maxGroups]    const ExtEventType        pickDown        rh_Muted        lh_Vibrato        altStroke        letRing        vibratoSpeed        vibratoDepth        triggerPT        slideIn        slideOut    end const    Playing_on_init()    Board_on_init()        family velocityArtZones        declare rh_Muted_Down[2] := (26, 50)        declare rh_Muted_Up[2] := (0, 25)        declare rh_Opened_Down[2] := (76, 100)        declare rh_Opened_Up[2] := (51, 75)        declare lh_Vibrato[2] := (101, 127)        // declare letRing_Down[2] := (127, 127)        // declare letRing_Up[2] := (126, 126)    end family    PitchTable_on_init()	{ ********* DECLARE UI *************** }    family UI        declare ui_button triggerPT[7]        declare ui_switch softMute        declare ui_switch rh_Muted        declare ui_switch lh_Vibrato        declare ui_switch altStroke        declare ui_switch letRing        declare ui_switch pickVelocityControl        declare ui_button debugClear        declare ui_knob attackSoftness (0, 100, 1)        // declare ui_knob vibratoSpeed (-50, 50, 1)        declare ui_knob vibratoSpeed (0, 100, 1)        declare ui_knob vibratoDepth (0, 100, 1)        declare ui_label label (2,6)        declare ui_label label2 (2,6)    end family    for i := 0 to Const.stringCount        UI.softMute := 0        if (i = Const.stringCount)            set_button_properties(UI.triggerPT[i], "A")        else             set_button_properties(UI.triggerPT[i], i+1)        end if    end for        set_text(UI.label,"")     set_text(UI.label2,"")     UI.softMute := 0    set_text(UI.softMute, "Soft P.M.")    UI.rh_Muted := playModeGlobal.rh_Muted    set_text(UI.rh_Muted, "P.M.")    UI.lh_Vibrato := playModeGlobal.lh_Vibrato    set_text(UI.lh_Vibrato, "Vibrato")    UI.altStroke := playModeGlobal.altStroke    set_text(UI.altStroke, "Alt Stroke")    UI.letRing := playModeGlobal.letRing    set_text(UI.letRing, "Let Ring")    UI.pickVelocityControl := 1    if (playModeGlobal.altStroke = 1)        UI.pickVelocityControl := 0    end if    set_text(UI.pickVelocityControl, "Velocity Control")    UI.attackSoftness := 0    set_text(UI.attackSoftness, "Att. Softness")        UI.vibratoSpeed := VIBRATO_SPEED_DEFAULT    set_text(UI.vibratoSpeed, "Vib. Speed")    set_knob_defval(UI.vibratoSpeed, VIBRATO_SPEED_DEFAULT)    UI.vibratoDepth := 0    set_text(UI.vibratoDepth, "Vib. Depth")    set_knob_defval(UI.vibratoDepth, 0)    set_text(UI.debugClear, "Debug Clear")    UI.debugClear := 0    { ************ MISC INIT ************ }    set_listener($NI_SIGNAL_TRANSP_STOP,1)    set_listener($NI_SIGNAL_TIMER_MS, 1000) // micro seconds    SetMathMode(ALL, CD)end onon note    message("")    onNote()end onon release     message("")    onRelease()end onfunction onNote()    ignore_event($EVENT_ID)    declare tmp    declare tmp2    declare string    declare fret    declare i    tmp := maxVoicesReached() // no room for new note ?     string := getString($EVENT_NOTE)    fret := getFret($EVENT_NOTE)    if (tmp = 0 and string > 0 and fret # -1) // if max voices not reached        i := Playing_getIndex($EVENT_NOTE, string) // is this note on this string is already playing?         if (i # -1)            // Playing_getActiveProperty(playMode.letRing, i, tmp2, tmp)            // if (i >= 0 { and tmp2 = 1 })                // found this note playing, but it rings in let ring mode, we need to stop it now and start the new one                // stopped note pushes to ghost notes, so we can process its EVENT_ID on release correctly                Playing_setPropertyTree(ghost, i, 1, tmp) // make ghost             // end if                    end if        // stop all notes playing on this string        stopNotesOnString(string)        nextNoteInit()        // creating new note        i := Playing_push(-1, $EVENT_NOTE, string, fret, 1)        if (i # -1)            setPlayMode(i, $EVENT_VELOCITY)                    end if        Groups_prepare(i)        // starting the new note        Playing[i].sys := play_note($EVENT_NOTE, getVelocity(string, fret), Playing[i].playMode.offset, Playing[i].playMode.duration)        Playing_startChildren(i)        Playing_timeOperationsStartWithChilds(i)            end if    if (tmp = 1)        message(@MSG_MAX_VOICE_REACHED)    end if        debug_Strings()    debug_Playing()end functionfunction onRelease()    declare stop    declare i    declare j    stop := -1        i := Playing_getIndex($EVENT_NOTE, 0)    j := Playing_getGhostIndex($EVENT_ID)    // debug2(i & " " & j)    if (i # -1 and j = -1)        declare ai        ai := Playing_getActiveIndex(i)        if (ai # -1)            if (Playing[ai].playMode.letRing # 1)                stop := i            end if            if (Playing[ai].playMode.slideIn = 1 and Playing[ai].parent # -1)                change_vol(Playing[Playing[ai].parent].sys, VOLUME_DEFAULT, 0)                Playing[Playing[ai].parent].active := 1                Playing_resetItem(ai)                stop := -1            end if        end if        // Playing_getActiveProperty(playMode.letRing, i, tmp2, tmp)        // if (tmp2 # 1) /if note started with let ring mode then do not stop it        //     stop := i        // end if    end if    if (j >= 0)        Playing_resetItemWithChilds(j);    end if    if (stop # -1)        stopNote(stop)    end if    // debug("end on release")    // debug_Playing()    debug("release " & $EVENT_ID)    end functionon_pgs_changed    if (pgs_key_exists(pgs_pitchTableChanged))        Globals.pitchTableChanged := pgs_get_key_val(pgs_pitchTableChanged, 0)    end if    if (pgs_key_exists(pgs_pitchTableIndex))        Globals.pitchTableIndex := pgs_get_key_val(pgs_pitchTableIndex, 0)        if (pgs_key_exists(pgs_pitchTableTimeLength))            pitchTables[Globals.pitchTableIndex].timeLength := pgs_get_key_val(pgs_pitchTableTimeLength, 0)        end if        if (pgs_key_exists(pgs_pitchTablePitchRange))            pitchTables[Globals.pitchTableIndex].pitchRange := pgs_get_key_val(pgs_pitchTablePitchRange, 0)        end if        //  if (Globals.pitchTableChanged = 1)        //     // apply table changes        //     debug_PitchTable()        // end if                if (pgs_key_exists(pgs_pitchTable))            // for i := 0 to num_elements(pitchTables[Globals.pitchTableIndex].columns)-1            for i := 0 to Const.pitchTableColumnCount-1                pitchTables[Globals.pitchTableIndex].columns[i] := pgs_get_key_val(pgs_pitchTable, i)            end for        end if    end ifend_on{ ********** FUNCTIONS *********** } function stopAllNotes    declare i    for i := 0 to Globals.maxVoices-1        if (Playing[i].parent = -1)            stopNote(i)        end if    end for    end functionfunction stopNotesOnString(string)    declare i    for i := 0 to Globals.maxVoices-1        if (Playing[i].string = string and Playing[i].parent = -1)            stopNote(i)        end if    end forend functionfunction stopNote(i)    declare j    // stop all children    for j := 0 to Globals.maxVoices-1        if (Playing[j].parent = i)            note_off(Playing[j].sys)        end if    end for    note_off(Playing[i].sys)    if (Playing[i].ghost = 0)         Playing_resetItemWithChilds(i)    end ifend functionfunction nextNoteInit    if (playModeGlobal.altStroke = 1 and UI.pickVelocityControl = 0)        if (playModeGlobal.pickDown = 1)            playModeGlobal.pickDown := 0        else             playModeGlobal.pickDown := 1        end if    end ifend functionfunction maxVoicesReached() -> result    declare i := 0    while (i < Globals.maxVoices and Playing[i].sys # -1)        inc(i)    end while        result := 0    if (i = Globals.maxVoices)        result := 1    end if    end function