import "import/Const.ksp"import "import/Array.ksp"import "import/Event.ksp"import "import/PlayMode.ksp"import "import/Playing.ksp"import "import/UI.ksp"import "import/Control.ksp"import "import/Groups.ksp"import "import/Board.ksp"import "import/debug.ksp"// import "import/PitchTable.ksp"import "import/Functions.ksp" as Funcsimport "import/KSPMathV702.ksp"on init    {#pragma save_compiled_source solo-s1.txt}    struct _GuitarNote        declare note := -1        declare string        declare fret                declare startTime    end struct    Const_on_init()    Event_on_init()    message("")    set_script_title("S1")	make_perfview	set_ui_height_px(300)    { *********** LOCAL VARS ********** }	{ ********* DECLARE VARIABLES ********** }    declare @MSG_MAX_VOICE_REACHED := "Max voices reached"    declare const VOLUME_NONE := -100000    declare const VOLUME_MIN := -66000    declare const VOLUME_DEFAULT := 0    declare const VOLUME_MAX := 0    declare const VOLUME_GHOST_NOISE := 9000    declare const VIBRATO_SPEED_DEFAULT := 55    family timeOperationPeriods        declare fadeIn := 1 // ms        declare vibrato := 1         declare pitchTable := 1     end family    family timeOperationTotals        declare fadeIn := 30 // ms        declare vibrato := 0     end family    family timeOperationValues        declare fadeIn_start        declare fadeIn_end        declare vibratoDepthMax := 1 * 100000 // 1 halftones in millicents    end family    timeOperationValues.fadeIn_start := VOLUME_MIN    timeOperationValues.fadeIn_end := VOLUME_DEFAULT    PlayMode_on_init()    declare activeGroups[Globals.maxGroups]    const ExtEventType        pickDown        rh_Muted        vibratoNatural        ghostNoise        lhNoise        altStroke        letRing        vibratoSpeed        vibratoDepth        triggerPT        slideIn        slideOut        slideUp        slideDown        slideUp2        slideDown2        pitchBend        pos        duration        tapping        slide        pitchBendNatural    end const    UI_on_init()    Board_on_init()        family velocityArtZones        declare rh_Muted_Down[2] := (26, 50)        declare rh_Muted_Up[2] := (0, 25)        declare rh_Opened_Down[2] := (76, 100)        declare rh_Opened_Up[2] := (51, 75)        declare lh_Vibrato[2] := (101, 127)        // declare letRing_Down[2] := (127, 127)        // declare letRing_Up[2] := (126, 126)    end family    // PitchTable_on_init()	{ ********* DECLARE UI *************** }    Playing_on_init()    { ************ MISC INIT ************ }    set_listener($NI_SIGNAL_TRANSP_STOP,1)    set_listener($NI_SIGNAL_TIMER_MS, 1000) // micro seconds    SetMathMode(ALL, CD)end onon note    // message("")    onNote()end onon release     // message("")    onRelease()end on// TODO:// 1. "Chord" mode: every note sets to new string, rest are ignored.// 2. function onNote()    ignore_event($EVENT_ID)    declare max    declare string    declare fret    declare i    max := Playing_maxVoicesReached() // no room for new note ?     chooseLastNote($EVENT_NOTE)    Board_setNote($EVENT_NOTE)    Strings_analyze()    // debug_Strings2()    if (max = 0 and nextNote.string > 0 and nextNote.fret >= 0 and nextNote.fret <= Const.fretCount-1 and nextNote.string <= Const.stringCount) // if max voices not reached        PlayMode_nextNoteInit()        setPlayMode($EVENT_VELOCITY, nextNote.string, $EVENT_NOTE)        // stop all notes playing on this string        Playing_stopNotesOnString(nextNote.string)        // creating new note        i := Playing_push(-1, $EVENT_NOTE, nextNote.string, nextNote.fret, 1, $EVENT_VELOCITY)        if (i # -1)            playModeGlobal.lastNoteStart := Playing[i].startTime            PlayMode_copy(Playing[i].playMode, playMode)            PlayMode_setOpString(i)                        Playing_playNote(i)            Playing_lhVibratoCheck(i)            Playing_PitchBendCheck(i)            UI_playNote(i)            Playing_startChildren(i)            Playing_timeOperationsStartWithChilds(i)            declare ai            ai := Playing_getActiveIndex(i)            change_vol(Playing[ai].sys, VOLUME_DEFAULT, 0)            Playing_ghostNoise()            mGuitarNote_copy(lastNote, nextNote)            Strings_setLastNote()        end if    end if    if (max = 1)        message(@MSG_MAX_VOICE_REACHED)    end if    Playing_setZones()        debug_Playing()    end functionfunction onRelease    declare i    declare ignore := 0    declare p    declare j    i := Playing_getIndexBySys($EVENT_ID)    if (i # -1)        if ((Playing[i].playMode.slideUp # 0 or Playing[i].playMode.slideDown # 0)  and Playing[i].parent # -1)            p := Playing[i].parent            Playing_resetItem(i)            j := Playing_chooseActive(p)            change_vol(Playing[j].sys, VOLUME_DEFAULT, 0)            Playing[j].active := 1        else if ((Playing[i].playMode.slideIn > 0 or Playing[i].playMode.slideUp2 > 0 or Playing[i].playMode.slideDown2 > 0) and Playing[i].parent # -1)            p := Playing[i].parent            Playing_resetItem(i)            j := Playing_chooseActive(p)            change_vol(Playing[j].sys, VOLUME_DEFAULT, 0)            Playing[j].active := 1                else if (Playing[i].playMode.letRing = 1)            ignore_event($EVENT_ID)            ignore := 1        else if (Playing[i].playmode.pickNoise > 0 and Playing[i].parent # -1)            p := Playing[i].parent            Playing_resetItem(i)            j := Playing_chooseActive(p)            change_vol(Playing[j].sys, VOLUME_DEFAULT, 0)            Playing[j].active := 1        else             // triggering slide out note            declare j            if (playModeGlobal.slide > 0)                j := Playing_push(-1, $EVENT_NOTE, Playing[i].gn.string, Playing[i].gn.fret, 1, Playing[i].eventVelocity)                 Playing[j].playMode.slideOut := 1                Playing[j].ghost := 1                Playing_playNote(j)                declare group_index                declare ev                Playing[j].valueForSampleSpeed := playModeGlobal.slide                                ev := getEngineSlideOutSpeed(Playing[j].valueForSampleSpeed)                set_engine_par($ENGINE_PAR_SPEED, ev, Playing[j].groupIndex, -1, -1)                change_vol(Playing[j].sys, VOLUME_DEFAULT, 0)                // debug_Playing()                // debug_Strings()            else                 // after note noise                declare note                note := Board_string2note(Playing[i].gn.string, 0)                j := Playing_push(-1, note, Playing[i].gn.string, 0, 1, Playing[i].eventVelocity)                Playing[j].playMode.afterNoteNoise := 1                Playing[j].ghost := 1                Playing_playNote(j)                declare vol                vol := getLHNoiseVolume(UI.lhNoise)                change_vol(Playing[j].sys, vol, 0)                // declare ej                // ej := Event_push(5, EventType.afterNoteNoise)                // Event[ej].value := j            end if            Playing_stopChildren(i)            Playing_resetItem(i)              if (Playing[i].playMode.ghostNoise = 0)                Globals.lastNoteEndTime := Funcs.Time_getCurrentTime()            end if        end if    end if    // UI_release()    if (ignore = 0)         // debug("release ("& i &") " & $EVENT_ID & ", length: " & length)    end if// debug2("release ("&  $EVENT_ID )    Playing_setZones()end functionon_pgs_changed// on pgs_changed{    if (pgs_key_exists(pgs_pitchTableChanged))        Globals.pitchTableChanged := pgs_get_key_val(pgs_pitchTableChanged, 0)    end if    if (pgs_key_exists(pgs_pitchTableIndex))        Globals.pitchTableIndex := pgs_get_key_val(pgs_pitchTableIndex, 0)        if (pgs_key_exists(pgs_pitchTableTimeLength))            pitchTables[Globals.pitchTableIndex].timeLength := pgs_get_key_val(pgs_pitchTableTimeLength, 0)        end if        if (pgs_key_exists(pgs_pitchTablePitchRange))            pitchTables[Globals.pitchTableIndex].pitchRange := pgs_get_key_val(pgs_pitchTablePitchRange, 0)        end if        //  if (Globals.pitchTableChanged = 1)        //     // apply table changes        //     debug_PitchTable()        // end if                if (pgs_key_exists(pgs_pitchTable))            // for i := 0 to num_elements(pitchTables[Globals.pitchTableIndex].columns)-1            for i := 0 to Const.pitchTableColumnCount-1                pitchTables[Globals.pitchTableIndex].columns[i] := pgs_get_key_val(pgs_pitchTable, i)            end for        end if    end if}// end onend_onmacro mGuitarNote_reset(#gn#)    #gn#.fret := playModeGlobal.pos    #gn#.string := 6    #gn#.note := Board_string2note(#gn#.string, #gn#.fret)    #gn#.startTime := 0end macromacro mGuitarNote_copy(#d#, #s#)    #d#.note := #s#.note    #d#.fret := #s#.fret    #d#.string := #s#.string    #d#.startTime := #s#.startTimeend macro