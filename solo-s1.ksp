// import "import/Const.ksp" as SConston init    {#pragma save_compiled_source solo-s1.txt}    // SConst.on_init()    // SPitchTable.on_init()    message("")    set_script_title("S1")	make_perfview	set_ui_height_px(200)    { *********** LOCAL VARS ********** }    declare i    declare j    declare tmp    declare tmp2    declare tmp3    declare string    declare fret    declare stop	{ ********* DECLARE VARIABLES ********** }    declare @MSG_MAX_VOICE_REACHED := "Max voices reached"    declare const VOLUME_NONE := -100000    declare const VOLUME_MIN := -66000    declare const VOLUME_DEFAULT := 0    declare const VOLUME_MAX := 0    declare const VIBRATO_SPEED_DEFAULT := 55    family timeOperationPeriods        declare fadeIn := 1 // ms        declare vibrato := 1     end family    family timeOperationTotals        declare fadeIn := 30 // ms        declare vibrato := 0     end family    family timeOperationValues        declare fadeIn_start        declare fadeIn_end        declare vibratoDepthMax := 1 * 100000 // 1 halftones in millicents    end family    timeOperationValues.fadeIn_start := VOLUME_MIN    timeOperationValues.fadeIn_end := VOLUME_DEFAULT    // this is used for setting note play mode props at the moment new note starts,    family PlayMode        declare rh_Muted := 0        declare pickDown := 1        declare lh_Vibrato := 0        declare letRing := 0        declare legato := 0        declare offset := 0    end family        // this is used for keeping global play mode properties through time    family PlayModeGlobal        declare rh_Muted := 0        declare pickDown := 1        declare lh_Vibrato := 0        declare altStroke := 1        declare letRing := 0        declare legato := 0        declare vibratoSpeed        declare vibratoDepth := 0    end family    PlayModeGlobal.vibratoSpeed := VIBRATO_SPEED_DEFAULT    const ArtsCodes        o_pd        o_pu        m_pd        m_pu        v1    end const        family Globals        declare takeCounts[ArtsCodes.SIZE]        declare const maxVoices := 100        declare const maxGroups := 3        declare lastGroupIndex := -1    end family    for i := 0 to ArtsCodes.SIZE-1        Globals.takeCounts[i] := 3    end for    Globals.takeCounts[ArtsCodes.v1] := 2    declare activeGroups[Globals.maxGroups]    const ExtEventType        pickDown        rh_Muted        lh_Vibrato        altStroke        letRing        vibratoSpeed        vibratoDepth    end const           family Playing        declare sys[Globals.maxVoices] // EVENT_ID        declare note[Globals.maxVoices] // actual note        declare string[Globals.maxVoices] // string on the guitar        declare fret[Globals.maxVoices] // fret taken        { Play Mode properties}         declare letRing[Globals.maxVoices] // lets string sound after release        declare rh_Muted[Globals.maxVoices] // right hand muted articulation        declare pickDown[Globals.maxVoices] // sound production: 0 = pick up, 1 = pick down, ...  etc.        declare lh_Vibrato[Globals.maxVoices] // vibrato by left hand articulation        //  if # -1 than this note is a child note, connected to first taken note         // (used when triggering vibrato or slide while parent note is sounding)        declare parent[Globals.maxVoices]        declare active[Globals.maxVoices] // when several notes connected, one of them is active, i.e. sounds right now        // when the note stops because new the same note on the same string is triggered, first one is marked as ghost (and all its children)        // that is done, because on release we need to delineate old note from the new one or both will be released just because old was stopped         // ghost notes live till next release event and go away peacefully and silently while noone sees it.        declare ghost[Globals.maxVoices]        declare startTime[Globals.maxVoices]        declare to_fadeIn[Globals.maxVoices] // time operation "fade in": stores time tick        declare to_vibrato[Globals.maxVoices] // time operation "vibrato": stores time tick    end family    Playing_resetAll()    declare notes2strings[128]    declare notes2frets[128]    fillBoardTable()        family velocityArtZones        declare rh_Muted_Down[2] := (26, 50)        declare rh_Muted_Up[2] := (0, 25)        declare rh_Opened_Down[2] := (76, 100)        declare rh_Opened_Up[2] := (51, 75)        declare lh_Vibrato[2] := (101, 127)        // declare letRing_Down[2] := (127, 127)        // declare letRing_Up[2] := (126, 126)    end family    declare const pitchTableCount := 100    family PitchTable        // declare columns[pitchTableCount, 128] //SConst.pitchTableColumnCount        declare time[pitchTableCount]        declare pitchRange[pitchTableCount]    end family    family PGS        declare pitchTableChanged := 0        declare pitchTableIndex := -1    end family    	{ ********* DECLARE UI *************** }    family UI        declare ui_switch softMute        declare ui_switch rh_Muted        declare ui_switch lh_Vibrato        declare ui_switch altStroke        declare ui_switch letRing        declare ui_switch pickVelocityControl        declare ui_button debugClear        declare ui_knob attackSoftness (0, 100, 1)        // declare ui_knob vibratoSpeed (-50, 50, 1)        declare ui_knob vibratoSpeed (0, 100, 1)        declare ui_knob vibratoDepth (0, 100, 1)        declare ui_label label (2,6)        declare ui_label label2 (2,6)    end family        set_text(UI.label,"")     set_text(UI.label2,"")     UI.softMute := 0    set_text(UI.softMute, "Soft P.M.")    UI.rh_Muted := PlayModeGlobal.rh_Muted    set_text(UI.rh_Muted, "P.M.")    UI.lh_Vibrato := PlayModeGlobal.lh_Vibrato    set_text(UI.lh_Vibrato, "Vibrato")    UI.altStroke := PlayModeGlobal.altStroke    set_text(UI.altStroke, "Alt Stroke")    UI.letRing := PlayModeGlobal.letRing    set_text(UI.letRing, "Let Ring")    UI.pickVelocityControl := 1    if (PlayModeGlobal.altStroke = 1)        UI.pickVelocityControl := 0    end if    set_text(UI.pickVelocityControl, "Velocity Control")    UI.attackSoftness := 0    set_text(UI.attackSoftness, "Att. Softness")        UI.vibratoSpeed := VIBRATO_SPEED_DEFAULT    set_text(UI.vibratoSpeed, "Vib. Speed")    set_knob_defval(UI.vibratoSpeed, VIBRATO_SPEED_DEFAULT)    UI.vibratoDepth := 0    set_text(UI.vibratoDepth, "Vib. Depth")    set_knob_defval(UI.vibratoDepth, 0)    set_text(UI.debugClear, "Debug Clear")    UI.debugClear := 0    { ************ MISC INIT ************ }    set_listener($NI_SIGNAL_TRANSP_STOP,1)    set_listener($NI_SIGNAL_TIMER_MS, 1000) // micro seconds    Math.SetMathMode(ALL, CD)end onimport "import/KSPMathV702.ksp" as Mathimport "import/Control.ksp"import "import/PlayMode.ksp"import "import/Playing.ksp"import "import/Groups.ksp"import "import/Board.ksp"import "import/debug.ksp"// import "import/PitchTable.ksp" as SPitchTableimport "import/Functions.ksp" as Funcson note    message("")    ignore_event($EVENT_ID)        tmp := maxVoicesReached() // no room for new note ?     if (tmp = 0) // if max voices not reached        string := getString($EVENT_NOTE)        fret := getFret($EVENT_NOTE)        nextNoteInit()        setPlayMode($EVENT_VELOCITY, $EVENT_NOTE, string)        Groups_prepare()        i := Playing_getIndex($EVENT_NOTE, string) // is this note on this string is already playing?         if (i # -1)            Playing_getActiveProperty(letRing, i, tmp2, tmp)            if (i >= 0 { and tmp2 = 1 })                // found this note playing, but it rings in let ring mode, we need to stop it now and start the new one                // stopped note pushes to ghost notes, so we can process its EVENT_ID on release correctly                Playing_setPropertyTree(ghost, i, 1, tmp) // make ghost             end if                    end if        // stop all notes playing on this string        stopNotesOnString(string)        // starting the new note        tmp2 := play_note($EVENT_NOTE, getVelocity(string, fret), PlayMode.offset, 0)        i := Playing_push(tmp2, $EVENT_NOTE, string, fret, 1)        Playing_startChildren(i)        Playing_timeOperationsStartWithChilds(i)    else         message(@MSG_MAX_VOICE_REACHED)    end if        debug_Strings(PlayMode.legato)    debug_Playing()    end onon release     message("")    stop := -1        i := Playing_getIndex($EVENT_NOTE, 0)    j := Playing_getGhostIndex($EVENT_ID)    // debug2(i & " " & j)    if (i # -1 and j = -1)        Playing_getActiveProperty(letRing, i, tmp2, tmp)        if (tmp2 # 1) {if note started with let ring mode then do not stop it}            stop := i        end if    end if    if (j >= 0)        Playing_resetItemWithChilds(j);    end if    if (stop # -1)        stopNote(stop)    end if    // debug("end on release")    // debug_Playing()    // debug("release " & $EVENT_ID)end onon pgs_changed    if (pgs_key_exists(pgs_pitchTableIndex))        PGS.pitchTableIndex := pgs_get_key_val(pgs_pitchTableIndex, 0)    end if    if (pgs_key_exists(pgs_pitchTableChanged))        PGS.pitchTableChanged := pgs_get_key_val(pgs_pitchTableChanged, 0)        if (PGS.pitchTableChanged = 1)            // apply table changes        end if{        if (pgs_key_exists(pgs_pitchTable))            for i := 0 to num_elements(PitchTable.columns[PGS.pitchTableIndex])-1                PitchTable.columns[PGS.pitchTableIndex, i] = pgs_get_key_val(pgs_pitchTable, i)            end for        end if        }    end ifend on{ ********** FUNCTIONS *********** } function stopAllNotes    declare i    for i := 0 to Globals.maxVoices-1        if (Playing.parent[i] = -1)            stopNote(i)        end if    end for    end functionfunction stopNotesOnString(string)    declare i    for i := 0 to Globals.maxVoices-1        if (Playing.string[i] = string and Playing.parent[i] = -1)            stopNote(i)        end if    end forend functionfunction stopNote(i)    declare j    // stop all children    for j := 0 to num_elements(Playing.sys)-1        if (Playing.parent[j] = i)            note_off(Playing.sys[j])        end if    end for    note_off(Playing.sys[i])    if (Playing.ghost[i] = 0)         Playing_resetItemWithChilds(i)    end ifend functionfunction nextNoteInit    if (PlayModeGlobal.altStroke = 1 and UI.pickVelocityControl = 0)        if (PlayModeGlobal.pickDown = 1)            PlayModeGlobal.pickDown := 0        else             PlayModeGlobal.pickDown := 1        end if    end ifend functionfunction maxVoicesReached() -> result    declare i := 0    while (i < Globals.maxVoices and Playing.sys[i] # -1)        inc(i)    end while        result := 0    if (i = Globals.maxVoices)        result := 1    end if    end function