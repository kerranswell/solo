import "import/Const.ksp"import "import/PlayMode.ksp"import "import/Playing.ksp"import "import/UI.ksp"import "import/Control.ksp"import "import/Groups.ksp"import "import/Board.ksp"import "import/debug.ksp"// import "import/PitchTable.ksp"import "import/Functions.ksp" as Funcsimport "import/KSPMathV702.ksp"on init    {#pragma save_compiled_source solo-s1.txt}    struct _GuitarNote        declare note := -1        declare string        declare fret            end struct    Const_on_init()    message("")    set_script_title("S1")	make_perfview	set_ui_height_px(300)    { *********** LOCAL VARS ********** }	{ ********* DECLARE VARIABLES ********** }    declare @MSG_MAX_VOICE_REACHED := "Max voices reached"    declare const VOLUME_NONE := -100000    declare const VOLUME_MIN := -66000    declare const VOLUME_DEFAULT := 0    declare const VOLUME_MAX := 0    declare const VIBRATO_SPEED_DEFAULT := 55    family timeOperationPeriods        declare fadeIn := 1 // ms        declare vibrato := 1         declare pitchTable := 1     end family    family timeOperationTotals        declare fadeIn := 30 // ms        declare vibrato := 0     end family    family timeOperationValues        declare fadeIn_start        declare fadeIn_end        declare vibratoDepthMax := 1 * 100000 // 1 halftones in millicents    end family    timeOperationValues.fadeIn_start := VOLUME_MIN    timeOperationValues.fadeIn_end := VOLUME_DEFAULT    PlayMode_on_init()    declare activeGroups[Globals.maxGroups]    const ExtEventType        pickDown        rh_Muted        lh_Vibrato        altStroke        letRing        vibratoSpeed        vibratoDepth        triggerPT        slideIn        slideOut        pitchBend        pos        duration    end const    UI_on_init()    Board_on_init()        family velocityArtZones        declare rh_Muted_Down[2] := (26, 50)        declare rh_Muted_Up[2] := (0, 25)        declare rh_Opened_Down[2] := (76, 100)        declare rh_Opened_Up[2] := (51, 75)        declare lh_Vibrato[2] := (101, 127)        // declare letRing_Down[2] := (127, 127)        // declare letRing_Up[2] := (126, 126)    end family    // PitchTable_on_init()	{ ********* DECLARE UI *************** }    Playing_on_init()    { ************ MISC INIT ************ }    set_listener($NI_SIGNAL_TRANSP_STOP,1)    set_listener($NI_SIGNAL_TIMER_MS, 1000) // micro seconds    SetMathMode(ALL, CD)end onon note    // message("")    onNote()end onon release     // message("")    onRelease()end onfunction onNote()    ignore_event($EVENT_ID)    declare max    declare string    declare fret    declare i    max := Playing_maxVoicesReached() // no room for new note ?     Board_setNote($EVENT_NOTE)    if (max = 0 and nextNote.string > 0 and nextNote.fret >= 0 and nextNote.fret <= Const.fretCount-1) // if max voices not reached        PlayMode_nextNoteInit()        setPlayMode($EVENT_VELOCITY, nextNote.string, $EVENT_NOTE)        // stop all notes playing on this string        Playing_stopNotesOnString(nextNote.string)        // creating new note        i := Playing_push(-1, $EVENT_NOTE, nextNote.string, nextNote.fret, 1)        if (i # -1)            playModeGlobal.lastNoteStart := Playing[i].startTime            PlayMode_copy(Playing[i].playMode, playMode)            PlayMode_setOpString(i)            Playing_playNote(i)            UI_playNote(i)            Playing_startChildren(i)            Playing_timeOperationsStartWithChilds(i)            declare ai            ai := Playing_getActiveIndex(i)            change_vol(Playing[ai].sys, VOLUME_DEFAULT, 0)        end if    end if    if (max = 1)        message(@MSG_MAX_VOICE_REACHED)    end if        debug_Strings()    debug_Playing()    end functionfunction onRelease    declare i    declare ignore := 0    declare length := 0    i := Playing_getIndexBySys($EVENT_ID)    if (i # -1)        if (Playing[i].playMode.slideIn > 0 and Playing[i].parent # -1)            // TODO: Need to choose what of the childs to activate depending on play mode (vibrato eg.)            change_vol(Playing[Playing[i].parent].sys, VOLUME_DEFAULT, 0)            Playing[Playing[i].parent].active := 1            Playing_resetItem(i)        else if (Playing[i].playMode.letRing = 1)            ignore_event($EVENT_ID)            ignore := 1        else             length := Funcs.Time_getCurrentTime() - Playing[i].startTime            // triggering slide out note            if (playModeGlobal.pm.slideOut > 0)                declare j                j := Playing_push(-1, $EVENT_NOTE, Playing[i].gn.string, Playing[i].gn.fret, 1)                PlayMode_copy(Playing[j].playMode, Playing[i].playMode)                Playing[j].playMode.slideOut := playModeGlobal.pm.slideOut                Playing[j].ghost := 1                Playing_playNote(j)                declare group_index                declare ev                group_index := Globals.lastGroupIndex                ev := epSpeed(V2E, Funcs.linearEq(Playing[j].playMode.slideOut, 1, 30, 127, 150, 100) / 10)                 set_engine_par($ENGINE_PAR_SPEED, ev, group_index, -1, -1)                            change_vol(Playing[j].sys, VOLUME_DEFAULT, 0)                debug_Playing()                debug_Strings()            end if            Playing_stopChildren(i)            Playing_resetItem(i)          end if    end if    // UI_release()    if (ignore = 0)         // debug("release ("& i &") " & $EVENT_ID & ", length: " & length)    end ifend functionon_pgs_changed// on pgs_changed{    if (pgs_key_exists(pgs_pitchTableChanged))        Globals.pitchTableChanged := pgs_get_key_val(pgs_pitchTableChanged, 0)    end if    if (pgs_key_exists(pgs_pitchTableIndex))        Globals.pitchTableIndex := pgs_get_key_val(pgs_pitchTableIndex, 0)        if (pgs_key_exists(pgs_pitchTableTimeLength))            pitchTables[Globals.pitchTableIndex].timeLength := pgs_get_key_val(pgs_pitchTableTimeLength, 0)        end if        if (pgs_key_exists(pgs_pitchTablePitchRange))            pitchTables[Globals.pitchTableIndex].pitchRange := pgs_get_key_val(pgs_pitchTablePitchRange, 0)        end if        //  if (Globals.pitchTableChanged = 1)        //     // apply table changes        //     debug_PitchTable()        // end if                if (pgs_key_exists(pgs_pitchTable))            // for i := 0 to num_elements(pitchTables[Globals.pitchTableIndex].columns)-1            for i := 0 to Const.pitchTableColumnCount-1                pitchTables[Globals.pitchTableIndex].columns[i] := pgs_get_key_val(pgs_pitchTable, i)            end for        end if    end if}// end onend_onmacro mGuitarNote_reset(#gn#)    #gn#.note := -1    #gn#.fret := -1    #gn#.string := 0end macromacro mGuitarNote_copy(#d#, #s#)    #d#.note := #s#.note    #d#.fret := #s#.fret    #d#.string := #s#.stringend macro